<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SECeD - Panel Radios</title>
  <link rel="stylesheet" href="styles.css?v=40" />
  <meta name="theme-color" content="#0b1f12" />

  <style>
    /* Solo lectura base (sin men√∫s ni franjas) */
    .viewer .menu-btn, .viewer .menu, .viewer .hist-btn, .viewer .tooltip { display: none !important; }
    .viewer .time-stack { display: none !important; }

    /* NO bloquear pointer-events globalmente: el JS valida elegibilidad en el click */
    /* .viewer .card, .viewer .card * { pointer-events: none; cursor: default; } */

    /* Elegible ‚Üí clic habilitado y ‚Äúblanco brillo‚Äù */
    .viewer .card.radio-eligible,
    .viewer .card.radio-eligible * {
      pointer-events: auto !important;
      cursor: pointer !important;
    }
    .card.radio-eligible {
      background: #ffffff !important;
      color: #111 !important;
      border-color: #e5e7eb !important;
      box-shadow: 0 0 0 2px rgba(34,197,94,.35) inset;
    }

    /* No elegibles ‚Üí VISIBLES pero atenuadas (nunca las ocultamos) */
    .card.radio-locked {
      display: block !important;
      opacity: .45;
      filter: grayscale(.2);
      pointer-events: none;
      cursor: default !important;
    }

    /* Ya clicadas por este radio ‚Üí amarillas persistentes (sin clic) */
    .card.radio-clicked-by-me {
      display: block !important;
      background: #fef08a !important;
      border-color: #eab308 !important;
      box-shadow: 0 0 0 2px rgba(234,179,8,.35) inset;
      pointer-events: none;
      cursor: default !important;
    }

    /* Feedback al clicar (ef√≠mero) */
    .card.radio-clicking {
      background: #fef08a !important;
      border-color: #eab308 !important;
      box-shadow: 0 0 0 2px rgba(234,179,8,.35) inset;
    }

    .radio-inline { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    #btnRadio {
      border: 1px solid var(--btn-border);
      background: #0c2415;
      color: #eafff7;
      border-radius: 8px;
      padding: 8px 10px;
      font-weight: 700;
      cursor: pointer;
    }

    .radio-badge{
      position:absolute; top:14px; right:14px;
      background:#ffd60a; color:#0f1300;
      border:1px solid #e9b400; border-radius:9999px;
      padding:6px 12px; font-weight:900; font-size:18px; letter-spacing:.3px;
      box-shadow:0 6px 16px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.35);
      user-select:none; pointer-events:none;
    }

    .tramo-picker { position: relative; }
    .tramo-menu { z-index: 1000; }

    /* Toast simple */
    #toast {
      position: fixed; left: 50%; bottom: 18px; transform: translateX(-50%);
      background: #0b1f12; color: #eafff7; padding: 8px 12px; border-radius: 10px;
      border: 1px solid #13301e; font-weight: 700; display: none; z-index: 9999;
    }
    #toast.ok { background: #065f46; border-color: #0c7a5c; }
    #toast.err { background: #7f1d1d; border-color: #991b1b; }

    /* En Panel Radio ignoramos el estado de 'llegada' del editor/visor */
  .viewer .card.selected {
  background: #ffffff !important;
  color: #111 !important;
  border-color: #e5e7eb !important;
  box-shadow: none !important;
  opacity: 1 !important;
  filter: none !important;
}

    /* En Panel Radio ignoramos el amarillo de llegada del visor/editor */
body.viewer.radio-skin .grid .card.selected {
  background: #ffffff !important;
  color: #111 !important;
  border-color: #e5e7eb !important;
  box-shadow: none !important;
  opacity: 1 !important;
  filter: none !important;
}






    
  </style>
</head>
<body class="radio-skin">
  <main class="app" style="position:relative;">
    <span id="radioBadge" class="radio-badge" aria-hidden="true" hidden>RADIO: ‚Äî</span>

    <div class="brand">
      <img src="logo.svg" alt="SECeD" class="brand-logo" onerror="this.src='logo.png'"/>
    </div>
    <h1>SECeD - Panel Radio</h1>

    <div class="clock-bar">
      <div class="clock">
        <span id="clockTime">--:--:--</span>
        <span class="tz" id="clockTz">Europe/Madrid</span>
        <span class="sync" id="clockSync">sincronizando‚Ä¶</span>
      </div>

      <div class="controls-right">
        <div class="tramo-picker">
          <div class="radio-inline">
            <button id="btnTramo" type="button" class="secondary">TRAMO ‚ñæ</button>
            <button id="btnRadio" type="button" title="Seleccionar Radio">RADIO: ‚Äî</button>
          </div>
          <div id="tramoMenu" class="tramo-menu hidden" role="menu">
            <div class="tm-section">
              <label for="tramoInput">Escribir tramo</label>
              <input id="tramoInput" type="text" placeholder="ej. tramo-1" />
              <button id="tramoGo" type="button" class="primary">Ir</button>
            </div>
            <div class="tm-section">
              <div class="tm-label">Recientes</div>
              <ul id="tramoRecent"></ul>
            </div>
          </div>
        </div>

        <div class="micro-panel">
          <button id="btnOperador" class="micro-btn" title="Cambiar usuario">üë§</button>
        </div>
      </div>
    </div>

    <section id="grid" class="grid" aria-live="polite"></section>
  </main>

  <div id="toast"></div>

  <!-- SDK Firebase -->
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore-compat.js"></script>

  <!-- Fallback de config + init + marcar VISOR (sin duplicar apps) -->
  <script>
    // VISOR base (para que app.js no enganche clics propios)
    window.VIEWER = true;
    document.body.classList.add('viewer');

    // Fallback config por si firebase-config.js no lleg√≥ a√∫n
    if (!window.FIREBASE_CONFIG) {
      window.FIREBASE_CONFIG = {
        apiKey: "AIzaSyDYRNhYISTXpHt_jK8dpT7aDUQskV_ZzuE",
        authDomain: "secedcp.firebaseapp.com",
        projectId: "secedcp",
        storageBucket: "secedcp.firebasestorage.app",
        messagingSenderId: "722200684437",
        appId: "1:722200684437:web:f8486e13dd6ec0bdaaf89c",
        measurementId: "G-XB0C93FM9W"
      };
    }
    try {
      if (firebase && firebase.apps && firebase.apps.length === 0) {
        firebase.initializeApp(window.FIREBASE_CONFIG);
      }
    } catch(e) { /* si ya est√° iniciada, seguimos sin error */ }
  </script>

  <!-- Tu config (si existe) sobreescribe el fallback -->
  <script src="firebase-config.js?v=15"></script>

  <script>
(function(){
  // Ejecutar despu√©s de cargar firebase-config.js
  document.addEventListener('DOMContentLoaded', function(){
    try{
      if (!window.firebase || !firebase.firestore) return;
      const TRAMO = (window.TRAMO_ID || new URLSearchParams(location.search).get('tramo') || '1').toString();
      const db = firebase.firestore();
      const tramoRef = db.collection('tramos').doc(TRAMO);

      // clave para saber si ya vimos este reset
      const LS_KEY = `seced_radios_reset_seen_${TRAMO}`;

      tramoRef.onSnapshot(snap=>{
        if (!snap.exists) return;
        const data = snap.data() || {};
        const ts = data.radiosResetAt && data.radiosResetAt.toMillis ? data.radiosResetAt.toMillis() : 0;
        const seen = Number(localStorage.getItem(LS_KEY) || '0');

        if (ts && ts > seen) {
          // nuevo reset global -> limpiar caches locales y recargar
          try {
            localStorage.setItem(LS_KEY, String(ts));
            // limpiar caches locales que puedan influir
            localStorage.removeItem('seced_radio_idx'); // si usas este para el n√∫mero de radio
            // (si guardas mas claves locales propias de radio, l√≠mpialas aqu√≠)

            // limpiar IndexedDB de Firestore (opcional; recarga despu√©s)
            try {
              indexedDB.deleteDatabase('firebase-firestore-database');
              indexedDB.deleteDatabase('firebaseLocalStorageDb');
              indexedDB.deleteDatabase('firebase-heartbeat-database');
            } catch {}

          } finally {
            // Forzar una recarga limpia
            location.reload();
          }
        }
      }, err => console.warn('reset listener error', err));
    } catch(e){ console.warn('reset listener setup error', e); }
  });
})();
</script>

  <!-- Sincronizaci√≥n y l√≥gica compartida -->
  <script src="sync.js?v=15"></script>
  <script src="app.js?v=15"></script>

  <!-- L√ìGICA RADIO -->
  <script>
    (function(){
      /* ===== Reloj online ===== */
      const TIMEZONE = 'Europe/Madrid';
      const clockTime = document.getElementById('clockTime');
      const clockTz = document.getElementById('clockTz');
      const clockSync = document.getElementById('clockSync');
      if (clockTz) clockTz.textContent = TIMEZONE;
      let timeOffsetMs = 0, tickTimer = null, resyncTimer = null;
      const pad = n => String(n).padStart(2,'0');
      const renderClock = () => {
        const d = new Date(Date.now() + timeOffsetMs);
        if (clockTime) clockTime.textContent = `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
      };
      const syncTime = async () => {
        try {
          if (clockSync) { clockSync.textContent = 'sincronizando‚Ä¶'; clockSync.className = 'sync'; }
          const res = await fetch(`https://worldtimeapi.org/api/timezone/${encodeURIComponent(TIMEZONE)}`, { cache: 'no-store' });
          if (!res.ok) throw new Error('HTTP ' + res.status);
          const data = await res.json();
          const apiMs = Date.parse(data.datetime);
          timeOffsetMs = apiMs - Date.now();
          if (clockSync) { clockSync.textContent = 'ok'; clockSync.className = 'sync ok'; }
        } catch {
          if (clockSync) { clockSync.textContent = 'sin conexi√≥n'; clockSync.className = 'sync err'; }
        }
      };
      const startClock = () => {
        clearInterval(tickTimer); tickTimer = setInterval(renderClock, 1000); renderClock();
        clearInterval(resyncTimer); resyncTimer = setInterval(syncTime, 5*60*1000);
      };
      syncTime().then(startClock);

      /* ===== Helper UI ===== */
      const toast = (msg, kind='ok')=>{
        const t = document.getElementById('toast');
        if(!t) return; t.textContent = msg; t.className=''; t.classList.add(kind); t.style.display='block';
        setTimeout(()=>{ t.style.display='none'; }, 1200);
      };

      /* ===== Selecci√≥n de RADIO ===== */
      const btnRadio = document.getElementById('btnRadio');
      const radioBadge = document.getElementById('radioBadge');
      function getRadio(){ try { return localStorage.getItem('seced_radio') || ''; } catch { return ''; } }
      function setRadio(v){ try { localStorage.setItem('seced_radio', String(v||'')); } catch {} }
      function getRadioIndex(){ const r = parseInt(getRadio(),10); return Number.isFinite(r) && r>0 ? r : 1; }

      function clickedKey(){ const tramo=(window.TRAMO_ID||new URLSearchParams(location.search).get('tramo')||'1').toString(); return `seced_radio_clicked:${tramo}:${getRadioIndex()}`; }
      function loadClickedSet(){ try { return new Set(JSON.parse(localStorage.getItem(clickedKey())||'[]')); } catch { return new Set(); } }
      function saveClickedSet(set){ try { localStorage.setItem(clickedKey(), JSON.stringify(Array.from(set))); } catch {} }
      let clickedSet = loadClickedSet();

      function updateRadioUI(){
        const r = getRadio();
        if (btnRadio) btnRadio.textContent = 'RADIO: ' + (r ? r : '‚Äî');
        if (radioBadge) { radioBadge.textContent = 'RADIO: ' + (r ? r : '‚Äî'); radioBadge.hidden = !r; }
        clickedSet = loadClickedSet();     // set propio de este radio/tramo
        setTimeout(applyEligibility, 0);
      }
      if (btnRadio) {
        btnRadio.addEventListener('click', () => {
          const curr = getRadio();
          const val = prompt('Introduce tu n√∫mero de RADIO (1,2,3‚Ä¶):', curr || '1');
          if (val === null) return;
          const clean = String(val).trim();
          setRadio(clean);
          updateRadioUI();
        });
      }
      updateRadioUI();

      /* ===== Firestore: estado por radio ===== */
      const TRAMO = (new URLSearchParams(location.search).get('tramo') || window.TRAMO_ID || '1').toString();
      const db = firebase.firestore();
      let radiosCol = null;
      try {
        radiosCol = db.collection('tramos').doc(TRAMO).collection('radios');
      } catch(e) {
        console.warn('Firestore no disponible a√∫n:', e);
      }

      const radioState = new Map();
      if (radiosCol) {
        radiosCol.onSnapshot(snap=>{
          snap.docChanges().forEach(ch=>{
            const id = ch.doc.id;
            const d = ch.doc.data()||{};
            if (ch.type === 'removed') radioState.delete(id);
            else radioState.set(id, { last: typeof d.last==='number' ? d.last : 0 });
          });
          applyEligibility();
        }, err => {
          console.error('onSnapshot error:', err);
          toast('Error de sincronizaci√≥n', 'err');
        });
      }

      function getLastFor(value){
        const key = String(value);
        return (radioState.get(key)?.last) || 0; // 0 = nadie / sin doc
      }

      /* ===== ACCESO A ITEMS (para ver tSalida) ===== */
      const getItems = (typeof window._getItems === 'function') ? window._getItems : () => [];
      function getItemByValue(val){
        const n = Number(val);
        const arr = getItems() || [];
        return arr.find(x => Number(x.value) === n) || null;
      }

      /* ===== Elegibilidad =====
         - Regla base: last === (radio-1)
         - Gracia RADIO 1: si last>0 (arrastra estado viejo) PERO la tarjeta es NUEVA (tSalida <= 5 min), permitir clic igualmente.
      */
      const GRACE_MS = 5 * 60 * 1000; // 5 minutos
      function canThisRadioClick(value){
        const rIdx = getRadioIndex();            // 1,2,3‚Ä¶
        const last = getLastFor(value);          // 0 si sin doc
        if (last === (rIdx - 1)) return true;    // caso est√°ndar

        if (rIdx === 1 && last > 0) {
          const it = getItemByValue(value);
          if (it && it.tSalida && (Date.now() - it.tSalida) <= GRACE_MS) {
            return true; // ‚Äúnuevo de salida‚Äù aunque quede basura en /radios
          }
        }
        return false;
      }

      function applyEligibility(){
  const cards = document.querySelectorAll('#grid .card');
  const rIdx = getRadioIndex();
  cards.forEach(card=>{
    const val = card.dataset.value;
    if (!val) return;

    const eligible = canThisRadioClick(val);

    // üëá ESTO ES LA CLAVE:
    // Si el doc de radios para ese dorsal est√° "antes" de mi radio,
    // NO debo considerarlo "clicado por m√≠" aunque est√© en localStorage.
    const last = getLastFor(val);            // 0 si no hay doc (nuevo)
    const clickedLocal = clickedSet.has(String(val));
    const clickedByMe = clickedLocal && (last >= rIdx);

    // Si en local tengo ese dorsal como "clicado" pero last < rIdx, lo purgo:
    if (clickedLocal && !clickedByMe) {
      clickedSet.delete(String(val));
      saveClickedSet(clickedSet);
    }

    // Limpieza de clases anteriores + ignorar 'selected' del visor
    card.classList.remove('radio-eligible','radio-locked','radio-clicked-by-me','radio-clicking','selected');

    if (clickedByMe) {
      card.classList.add('radio-clicked-by-me');        // amarilla fija en MI panel
      card.title = `Clicada por RADIO ${rIdx}`;
    } else if (eligible) {
      card.classList.add('radio-eligible');             // blanca, clic habilitado
      card.title = `Elegible para RADIO ${rIdx} (clic para avanzar)`;
    } else {
      card.classList.add('radio-locked');               // visible atenuada
      card.title = `Esperando turno (RADIO ${last+1})`;
    }
  });
}



      // Reaplicar elegibilidad tras cada render del app.js
      const origOnRemote = window._onRemoteUpdate;
      if (typeof origOnRemote === 'function') {
        window._onRemoteUpdate = (arr)=>{ origOnRemote(arr); applyEligibility(); };
      } else {
        const obs = new MutationObserver(()=>applyEligibility());
        obs.observe(document.getElementById('grid'), {childList:true, subtree:true});
      }
      setTimeout(applyEligibility, 0);

      /* Watchdog: reaplica cada ~800 ms para no tener que recargar ni re-seleccionar radio */
      (function(){
        let _eligTimer = null;
        function startEligibilityWatchdog(){
          if (_eligTimer) clearInterval(_eligTimer);
          _eligTimer = setInterval(() => { try { applyEligibility(); } catch {} }, 800);
        }
        startEligibilityWatchdog();
      })();

      /* ===== Click para avanzar dorsal al siguiente RADIO ===== */
      document.getElementById('grid').addEventListener('click', async (ev)=>{
        const card = ev.target.closest('.card');
        if (!card) return;
        const val = card.dataset.value;
        if (!val) return;
        if (!card.classList.contains('radio-eligible')) return; // doble seguridad

        card.classList.add('radio-clicking');

        const rIdx = getRadioIndex();
        if (!radiosCol) return; // seguridad

        const docRef = radiosCol.doc(String(val));

        try {
          await db.runTransaction(async (tx)=>{
            const snap = await tx.get(docRef);
            const data = snap.exists ? (snap.data()||{}) : {};
            let last = (typeof data.last==='number') ? data.last : 0;

            // Acepta tambi√©n la ‚Äúgracia‚Äù si soy R1 y es nueva salida
            if (!(last === (rIdx - 1))) {
              if (rIdx === 1) {
                const it = getItemByValue(val);
                if (it && it.tSalida && (Date.now() - it.tSalida) <= GRACE_MS) {
                  last = 0; // tratamos como nuevo
                }
              }
            }
            if (last !== (rIdx - 1)) {
              throw new Error(`Condici√≥n no v√°lida: last=${last} para RADIO ${rIdx}`);
            }
            tx.set(docRef, {
             last: rIdx,
            marks: firebase.firestore.FieldValue.arrayUnion(rIdx) // ‚Üê guardamos el radio que clic√≥
            }, { merge:true });

            

          // Guardar ‚Äúclicado por este radio‚Äù (persistente por tramo+radio)
          clickedSet.add(String(val));
          saveClickedSet(clickedSet);

          // Auditor√≠a (no bloquear si falla)
          try {
            const aud = db.collection('tramos').doc(TRAMO).collection('auditoria');
            await aud.add({
              actor: (localStorage.getItem('seced_radio')||('RADIO '+rIdx)),
              action: 'radio_click',
              detail: { value: Number(val), radio: rIdx },
              ts: firebase.firestore.FieldValue.serverTimestamp(),
            });
          } catch(e){}

          toast(`Clic RADIO ${rIdx} ‚Üí dorsal ${val}`, 'ok');

        } catch (err) {
          toast('No se pudo avanzar: ' + err.message, 'err');
          card.classList.remove('radio-clicking');
          return;
        }

        // Recalcular (el snapshot har√° el resto)
        setTimeout(()=>{ applyEligibility(); }, 150);
      });

      /* ===== Fallback TRAMO (por si el men√∫ no abre) ===== */
      function sanitizeTramo(t){ return (t||'').trim().toLowerCase().replace(/[^\w-]+/g,'-').slice(0,64); }
      function goToTramo(t){
        const tramo = sanitizeTramo(t);
        if(!tramo) return;
        try{
          const k='seced_tramos_recent';
          const list=JSON.parse(localStorage.getItem(k)||'[]');
          const next=[tramo, ...list.filter(x=>x!==tramo)].slice(0,10);
          localStorage.setItem(k, JSON.stringify(next));
        }catch{}
        const p = new URLSearchParams(location.search);
        p.set('tramo', tramo);
        location.search = p.toString();
      }
      const btnTramo = document.getElementById('btnTramo');
      const tramoMenu = document.getElementById('tramoMenu');
      if (btnTramo) {
        btnTramo.addEventListener('click', (e) => {
          e.stopPropagation();
          setTimeout(() => {
            const noMenu = !tramoMenu;
            const stillHidden = tramoMenu && tramoMenu.classList.contains('hidden');
            if (noMenu || stillHidden) {
              const t = prompt('Indica el tramo (ej. 1 o tramo-1):', new URLSearchParams(location.search).get('tramo') || '1');
              if (t !== null) goToTramo(t);
            }
          }, 150);
        });
      }

      /* ===== Usuario (bot√≥n üë§) ===== */
      const btnOperador = document.getElementById('btnOperador');
      if (btnOperador) btnOperador.addEventListener('click', ()=>{
        const name = prompt('Nombre o identificador del operador:', localStorage.getItem('seced_operator')||'');
        if (name !== null) { try { localStorage.setItem('seced_operator', (name||'').trim()); } catch{} }
      });
    })();
  </script>
</body>
</html>
